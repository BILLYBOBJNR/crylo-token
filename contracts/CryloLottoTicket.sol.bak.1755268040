// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

// Import OpenZeppelin & Chainlink contracts
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

contract CryloLottoTicket is ERC721Enumerable, Ownable, VRFConsumerBaseV2 {
    IERC20 public immutable cryloToken;
    address public devWallet;
    address public prizeWallet;

    uint256 public nextTicketId = 1;
    uint256 public ticketPriceUSD = 2e18; // $2 in 18 decimals
    uint256 public minHoldUSD = 10e18;    // $10 minimum CRYLO hold
    uint256 public totalTicketsSold;

    // ==============================
    // ðŸ”® Chainlink VRF Setup Section
    // ==============================

    VRFCoordinatorV2Interface COORDINATOR;

    // TODO: Replace with actual Subscription ID from Chainlink dashboard
    uint64 public subscriptionId;

    // TODO: Replace with actual KeyHash from Chainlink docs for your network
    bytes32 public keyHash;

    // You may tweak these later
    uint32 public callbackGasLimit = 200000;
    uint16 public requestConfirmations = 3;
    uint32 public numWords = 1;

    // Tracks the last randomness request
    uint256 public lastRequestId;
    uint256 public lastRandomWord;

    // ==============================
    // ðŸ”Š Events
    // ==============================
    event TicketMinted(address indexed to, uint256 ticketId, uint256 pricePaidUSD);
    event WinnerSelected(address winner, uint256 ticketId);

    constructor(
        address _cryloToken,
        address _devWallet,
        address _prizeWallet,

        // TODO: Replace with your actual Chainlink values before deploy
        uint64 _subscriptionId,
        address _vrfCoordinator,
        bytes32 _keyHash
    )
        ERC721("Crylo Lottery Ticket", "CRYLOTICKET")
        Ownable(msg.sender)
        VRFConsumerBaseV2(_vrfCoordinator)
    {
        cryloToken = IERC20(_cryloToken);
        devWallet = _devWallet;
        prizeWallet = _prizeWallet;

        // Assign Chainlink settings
        subscriptionId = _subscriptionId;
        keyHash = _keyHash;
        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);
    }

    // ======================================
    // ðŸŽŸ Ticket Minting (requires CRYLO hold)
    // ======================================
    function mint() public {
        require(cryloToken.balanceOf(msg.sender) >= minHoldUSD, "Insufficient CRYLO hold");
        require(cryloToken.allowance(msg.sender, address(this)) >= ticketPriceUSD, "Approve CRYLO first");
        require(cryloToken.transferFrom(msg.sender, address(this), ticketPriceUSD), "Transfer failed");

        _safeMint(msg.sender, nextTicketId);
        emit TicketMinted(msg.sender, nextTicketId, ticketPriceUSD);
        nextTicketId++;
        totalTicketsSold++;
    }

    // ===================================
    // ðŸš€ Request Random Winner from VRF
    // ===================================
    function requestRandomWinner() external onlyOwner returns (uint256 requestId) {
        require(totalTicketsSold > 0, "No tickets sold");

        // This will trigger Chainlink VRF request
        requestId = COORDINATOR.requestRandomWords(
            keyHash,
            subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );

        lastRequestId = requestId;
    }

    // ===================================
    // ðŸŽ¯ Fulfilled by Chainlink VRF
    // ===================================
    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
        require(randomWords.length > 0, "No random word received");

        uint256 winningTicketId = (randomWords[0] % totalTicketsSold) + 1;
        address winner = ownerOf(winningTicketId);

        emit WinnerSelected(winner, winningTicketId);
        lastRandomWord = randomWords[0];
    }

    // ============================
    // ðŸ’¸ Admin Functions
    // ============================
    function withdraw(uint256 amount) public onlyOwner {
        require(cryloToken.transfer(devWallet, amount), "Withdrawal failed");
    }

    function setTicketPriceUSD(uint256 _newPrice) public onlyOwner {
        ticketPriceUSD = _newPrice;
    }

    function setMinHoldUSD(uint256 _newMinHold) public onlyOwner {
        minHoldUSD = _newMinHold;
    }

    function setCallbackGasLimit(uint32 _limit) public onlyOwner {
        callbackGasLimit = _limit;
    }
}
